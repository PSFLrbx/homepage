import Discord from 'discord.js';
import dotenv from 'dotenv';
import moment from 'moment-timezone';
dotenv.config();

const {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  StringSelectMenuBuilder,
  RoleSelectMenuBuilder,
  PermissionsBitField,
  ChannelType
} = Discord;

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers, GatewayIntentBits.MessageContent]
});

// Persistent configuration per guild – now filled from files
const config = {
  teamRoles: {},
  ringRoles: {},
  streamerRoles: {},      // If needed, set separately
  refereeRoles: {},       // If needed, set separately
  transactionChannel: {},
  demandChannel: {},
  suspensionChannel: {},
  commandChannel: {},
  coachCheckChannel: {},
  gametimeChannel: {},
  signingStatus: {},
  demandStatus: {},
  awards: []              // Store award configuration if needed
};

// Staff roles & ranking definitions
const validStaffRoles = ['University President', 'Head Coach', 'General Manager', 'Assistant Coach'];
const staffRanks = {
  'University President': 4,
  'Head Coach': 3,
  'General Manager': 2,
  'Assistant Coach': 1
};
const modifiableStaffRoles = ['Head Coach', 'General Manager', 'Assistant Coach'];

// In-memory storage for scheduled games (for live countdown updates)
let nextGameId = 1;
const scheduledGames = {};
// Structure: { guildId: [ { gameId, messageId, channelId, scheduledTime, homeTeamName, awayTeamName, authorId, streamerId, refereeId }, ... ] }

const timezoneMap = {
  'EST': 'America/New_York',
  'CST': 'America/Chicago',
  'MST': 'America/Denver',
  'PST': 'America/Los_Angeles'
};

function isAdminOrManageGuild(interaction) {
  return (
    interaction.memberPermissions.has(PermissionsBitField.Flags.Administrator) ||
    interaction.memberPermissions.has(PermissionsBitField.Flags.ManageGuild)
  );
}

// NEW: Load configuration from GitHub text files
async function loadConfigurationFromGitHub() {
  // Change this base URL to the raw URL of your GitHub repository
  const baseUrl = 'https://raw.githubusercontent.com/yourusername/yourrepo/main/';
  const teamConfigUrl = baseUrl + 'teamConfigure.txt';
  const ringConfigUrl = baseUrl + 'ringConfigure.txt';
  const awardConfigUrl = baseUrl + 'awardConfigure.txt';
  const channelConfigUrl = baseUrl + 'channelConfigure.txt';

  try {
    const [teamRes, ringRes, awardRes, channelRes] = await Promise.all([
      fetch(teamConfigUrl),
      fetch(ringConfigUrl),
      fetch(awardConfigUrl),
      fetch(channelConfigUrl)
    ]);

    const [teamText, ringText, awardText, channelText] = await Promise.all([
      teamRes.text(),
      ringRes.text(),
      awardRes.text(),
      channelRes.text()
    ]);

    // Process team configuration – each line is a role name
    const teamRoleNames = teamText.split('\n').map(line => line.trim()).filter(line => line.length);
    // Process ring configuration – each line is a role name (award file is separate)
    const ringRoleNames = ringText.split('\n').map(line => line.trim()).filter(line => line.length);
    // Process award configuration (if used)
    const awardData = awardText.split('\n').map(line => line.trim()).filter(line => line.length);
    // Process channel configuration – each line is a channel ID in this order:
    // Transaction, Demand, Suspension, Coach-Check, Bot Command.
    const channelIds = channelText.split('\n').map(line => line.trim()).filter(line => line.length);

    // For each guild the bot is in, look up the roles/channels by name/ID.
    client.guilds.cache.forEach(guild => {
      // TEAM ROLES: match by role name
      const teamRoles = [];
      teamRoleNames.forEach(roleName => {
        const role = guild.roles.cache.find(r => r.name === roleName);
        if (role) {
          teamRoles.push(role.id);
        } else {
          console.warn(`Team role "${roleName}" not found in guild ${guild.id}`);
        }
      });
      config.teamRoles[guild.id] = teamRoles;

      // RING ROLES: match by role name
      const ringRoles = [];
      ringRoleNames.forEach(roleName => {
        const role = guild.roles.cache.find(r => r.name === roleName);
        if (role) {
          ringRoles.push(role.id);
        } else {
          console.warn(`Ring role "${roleName}" not found in guild ${guild.id}`);
        }
      });
      config.ringRoles[guild.id] = ringRoles;

      // CHANNEL CONFIGURATION:
      if (channelIds.length >= 5) {
        const transactionChannel = guild.channels.cache.get(channelIds[0]);
        const demandChannel = guild.channels.cache.get(channelIds[1]);
        const suspensionChannel = guild.channels.cache.get(channelIds[2]);
        const coachCheckChannel = guild.channels.cache.get(channelIds[3]);
        const commandChannel = guild.channels.cache.get(channelIds[4]);

        if (transactionChannel) config.transactionChannel[guild.id] = transactionChannel.id;
        else console.warn(`Transaction channel ID ${channelIds[0]} not found in guild ${guild.id}`);

        if (demandChannel) config.demandChannel[guild.id] = demandChannel.id;
        else console.warn(`Demand channel ID ${channelIds[1]} not found in guild ${guild.id}`);

        if (suspensionChannel) config.suspensionChannel[guild.id] = suspensionChannel.id;
        else console.warn(`Suspension channel ID ${channelIds[2]} not found in guild ${guild.id}`);

        if (coachCheckChannel) config.coachCheckChannel[guild.id] = coachCheckChannel.id;
        else console.warn(`Coach-check channel ID ${channelIds[3]} not found in guild ${guild.id}`);

        if (commandChannel) config.commandChannel[guild.id] = commandChannel.id;
        else console.warn(`Bot command channel ID ${channelIds[4]} not found in guild ${guild.id}`);
      } else {
        console.error('channelConfigure.txt does not contain enough channel IDs.');
      }
    });

    // Save award data if needed
    config.awards = awardData;

    console.log('Configuration successfully loaded from GitHub.');
  } catch (error) {
    console.error('Error loading configuration from GitHub:', error);
  }
}

client.once('ready', async () => {
  console.log(`Logged in as ${client.user.tag}!`);
  // Load configuration on startup
  await loadConfigurationFromGitHub();
});

// Utility: Calculate time until a given date
function timeUntil(dateObj) {
  const now = new Date();
  let diff = Math.floor((dateObj - now) / 1000);
  if (diff <= 0) return 'Game time has passed!';
  const days = Math.floor(diff / 86400);
  diff %= 86400;
  const hours = Math.floor(diff / 3600);
  diff %= 3600;
  const mins = Math.floor(diff / 60);
  const secs = diff % 60;
  return `${days ? days + 'd ' : ''}${hours ? hours + 'h ' : ''}${mins ? mins + 'm ' : ''}${secs}s`.trim();
}

// Periodically update scheduled game embeds with live countdown
setInterval(async () => {
  const now = new Date();
  for (const [guildId, games] of Object.entries(scheduledGames)) {
    for (const game of games) {
      const { gameId, messageId, channelId, scheduledTime, homeTeamName, awayTeamName, authorId, streamerId, refereeId } = game;
      if (!scheduledTime) continue;
      const channel = await client.channels.fetch(channelId).catch(() => null);
      if (!channel) continue;
      const discordTimestamp = Math.floor(moment(scheduledTime).unix());
      const embed = new EmbedBuilder()
        .setTitle(`**GAME SCHEDULED – ID: ${gameId}**`)
        .setThumbnail('https://raw.githubusercontent.com/495BC/PSFL-Bot/main/logo.png')
        .setDescription(`**Home Team:** ${homeTeamName}\n**Away Team:** ${awayTeamName}`)
        .addFields(
          { name: 'Scheduled Date/Time', value: moment(scheduledTime).format('LLLL'), inline: false },
          { name: 'Time Until Game', value: `<t:${discordTimestamp}:R>`, inline: false },
          { name: 'Streamer', value: streamerId ? `<@${streamerId}>` : '*(None)*', inline: true },
          { name: 'Referee', value: refereeId ? `<@${refereeId}>` : '*(None)*', inline: true }
        )
        .setFooter({ text: `Last updated: ${now.toLocaleTimeString()} | Scheduled by: ${authorId}` });
      try {
        const msg = await channel.messages.fetch(messageId);
        await msg.edit({ embeds: [embed] });
      } catch {
        // Message might be deleted or permissions insufficient.
      }
    }
  }
}, 1000);

// Build row of buttons for gametime announcements
function buildGameButtons() {
  return new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId('gametime_streamer')
      .setLabel('Streamer')
      .setStyle(ButtonStyle.Secondary),
    new ButtonBuilder()
      .setCustomId('gametime_referee')
      .setLabel('Referee')
      .setStyle(ButtonStyle.Secondary),
    new ButtonBuilder()
      .setCustomId('gametime_cancel')
      .setLabel('Cancel')
      .setStyle(ButtonStyle.Danger)
  );
}

// Interaction handling
client.on('interactionCreate', async interaction => {
  try {
    console.log(`Received interaction: Type=${interaction.type}`);
    if (interaction.isChatInputCommand()) {
      const guildId = interaction.guildId;
      // Enforce command channel if set and non-admin/manager
      if (!isAdminOrManageGuild(interaction) && config.commandChannel[guildId]) {
        if (interaction.channel.id !== config.commandChannel[guildId]) {
          return interaction.reply({ content: 'Please use the designated command channel for configuration commands.', ephemeral: true });
        }
      }
      const { commandName } = interaction;
      console.log(`Processing command: ${commandName}`);
      
      // New /setup command: load config from GitHub files
      if (commandName === 'setup') {
        await loadConfigurationFromGitHub();
        return interaction.reply({ content: 'Configuration loaded successfully from GitHub.', ephemeral: true });
      }
      
      if (commandName === 'settings') {
        const embed = new EmbedBuilder()
          .setTitle('Current Configuration Settings')
          .addFields(
            { name: 'Team Roles', value: config.teamRoles[guildId] ? config.teamRoles[guildId].map(id => `<@&${id}>`).join(', ') : 'Not configured', inline: false },
            { name: 'Ring Roles', value: config.ringRoles[guildId] ? config.ringRoles[guildId].map(id => `<@&${id}>`).join(', ') : 'Not configured', inline: false },
            { name: 'Transaction Channel', value: config.transactionChannel[guildId] ? `<#${config.transactionChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Demand Channel', value: config.demandChannel[guildId] ? `<#${config.demandChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Suspension Channel', value: config.suspensionChannel[guildId] ? `<#${config.suspensionChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Command Channel', value: config.commandChannel[guildId] ? `<#${config.commandChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Coach-Check Channel', value: config.coachCheckChannel[guildId] ? `<#${config.coachCheckChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Gametime Channel', value: config.gametimeChannel[guildId] ? `<#${config.gametimeChannel[guildId]}>` : 'Not configured', inline: true },
            { name: 'Signing Status', value: (config.signingStatus[guildId] === false) ? 'Disabled' : 'Enabled', inline: true },
            { name: 'Demand Status', value: (config.demandStatus[guildId] === false) ? 'Disabled' : 'Enabled', inline: true }
          )
          .setTimestamp(new Date());
        return interaction.reply({ embeds: [embed] });
      }
      
      if (commandName === 'ring-check') {
        const user = interaction.options.getUser('player') || interaction.user;
        const member = interaction.guild.members.cache.get(user.id);
        const ringRoleIds = config.ringRoles[interaction.guildId] || [];
        let count = 0;
        member.roles.cache.forEach(role => {
          if (ringRoleIds.includes(role.id)) count++;
        });
        return interaction.reply({ content: `<@${user.id}> possesses **${count}** ring(s).` });
      }
      
      // Other commands (membercount, aura, promote, demote, fo, release, sign, demand, suspend, unsuspend, fire-fo, coach-check, purge,
      // signing-status, demand-status, command-channel, gametime) remain unchanged.
      // … [rest of your command handling code, as in your original file, goes here] …
      
    }
    // Handle other interaction types (e.g. buttons for gametime) as before.
    else if (interaction.isButton()) {
      // Gametime button interactions: streamer/referee claim and cancel.
      const guildId = interaction.guildId;
      if (!scheduledGames[guildId]) return;
      const game = scheduledGames[guildId].find(g => g.messageId === interaction.message.id);
      if (!game) return interaction.reply({ content: 'Game not found.', ephemeral: true });
      if (interaction.customId === 'gametime_cancel') {
        if (game.authorId !== interaction.user.id) {
          return interaction.reply({ content: 'Only the person who scheduled this game can cancel it.', ephemeral: true });
        }
        scheduledGames[guildId] = scheduledGames[guildId].filter(g => g !== game);
        await interaction.message.delete().catch(() => {});
        return interaction.reply({ content: 'Gametime announcement cancelled.', ephemeral: true });
      }
      if (interaction.customId === 'gametime_streamer') {
        const userRoles = interaction.member.roles.cache.map(r => r.id);
        const allowedStreamerRoles = config.streamerRoles[guildId] || [];
        if (!userRoles.some(r => allowedStreamerRoles.includes(r))) {
          return interaction.reply({ content: 'You do not have permission to claim the Streamer slot.', ephemeral: true });
        }
        if (game.streamerId === interaction.user.id) {
          game.streamerId = null;
          return interaction.reply({ content: 'You have unclaimed the Streamer slot.', ephemeral: true });
        }
        if (game.streamerId && game.streamerId !== interaction.user.id) {
          return interaction.reply({ content: 'The Streamer slot is already claimed.', ephemeral: true });
        }
        game.streamerId = interaction.user.id;
        return interaction.reply({ content: 'You have claimed the Streamer slot.', ephemeral: true });
      }
      if (interaction.customId === 'gametime_referee') {
        const userRoles = interaction.member.roles.cache.map(r => r.id);
        const allowedRefereeRoles = config.refereeRoles[guildId] || [];
        if (!userRoles.some(r => allowedRefereeRoles.includes(r))) {
          return interaction.reply({ content: 'You do not have permission to claim the Referee slot.', ephemeral: true });
        }
        if (game.refereeId === interaction.user.id) {
          game.refereeId = null;
          return interaction.reply({ content: 'You have unclaimed the Referee slot.', ephemeral: true });
        }
        if (game.refereeId && game.refereeId !== interaction.user.id) {
          return interaction.reply({ content: 'The Referee slot is already claimed.', ephemeral: true });
        }
        game.refereeId = interaction.user.id;
        return interaction.reply({ content: 'You have claimed the Referee slot.', ephemeral: true });
      }
    }
  } catch (error) {
    console.error('Unhandled interaction error:', error);
  }
});

console.log('DEBUG BOT_TOKEN:', process.env.BOT_TOKEN);
client.login(process.env.BOT_TOKEN);

function getStaffRank(member) {
  for (const roleName of Object.keys(staffRanks).sort((a, b) => staffRanks[b] - staffRanks[a])) {
    if (member.roles.cache.some(r => r.name === roleName)) return staffRanks[roleName];
  }
  return 0;
}
